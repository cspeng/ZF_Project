## C语言

###### 1.const的作用有哪些，谈一谈你对const的理解？

将const类型修饰符放在类型名之前，即可将类型名的标识符声明为具有该类型的const常量。并且是放在只读存储区，不允许在程序中改变其值。因此const常量只能在定义时赋初值，例如：const  double PI = 3.1415926;

作用：

（1）：向其他程序员传递一个消息，这个不要修改

（2）：让编译器产生更精简的代码，减少bug

（3）：合理保护只读数据，避免不必要的修改

使用位置：

（1）：定义常量，防止被修改

（2）：在函数参数中， 如果不期望子函数去修改被调用函数的某个数据，可以加以限制，提高程序的健壮性。

```c
 char * strcpy(char * dest,  const char *  src);
```

（3）在C++中类的使用

举例：

1.const修饰变量，指针的判断从右向左

```c
int b;
const int *a = &b;	//a是指针，int 是静态的，指向int,const修饰int
const int *const a = &b;//a是静态指针（第二个const修饰），指向int,这个int是静态的（第一个const修饰，这个变量是int的）
int const*const a= &b;											
```

（1）：只有一个const，如果const位于*左侧，表示指针所指向的数据是常量，不能通过解引用修改改数据，指针本身是变量，可以指向其他的内存地址。

（2）：只有一个const，如果const位于*右侧，表示指针本身是常量，不能指向其他内存地址；指针所值的数据可以通过解引用修改。

（3）：两个const，*左右各一个，表示指针和指针所值数据都不能修改。

```c
int * a[10];   //因为[]优先级高于*，因此是一个数组，每个成员类型为指针，指向int
int (*)a[10]; //因为()优先级高于[],因此，先看里面，是一个指针，指向的类型为一个数组

typedef void * VP;
const void *ptr;	//指针变量，指向const void 常量
const VP ptr;	//(void *)是一个整体，const指针，指向void变量
const int i==int const i;
VP const ptr == void * const ptr;
```

2.const修饰函数参数

传递过来的参数在函数内不能被修改

```c
void fun(const int a){
		a = 1;  //编译出错
}
```

3.const修饰函数返回值

3.1指针传递

如果返回值为const数据类型，未const的指针，返回值也必须一样。因为指针指向的数据是不能修改的

```c
#include <stdio.h>
const int *fun(){
    int b=2;
    int *a=&b;
    return a;
}
int main(int argc,char*argv[])
{
    const int *a=fun();
	//int *a = fun();  //编译错误
    printf("%d\n",*a);
    return 0;
}
```

3.2 按值传递

如果采用函数返回值采用值传递的方式，由于在此过程中产生一个副本，所以加const是没有意义的

4.const 的重要作用

在用指针进行传递参数时，常常以const加以修饰，可以保证传递来的参数不被修改，提高程序的健壮性。

5.const 修饰类的成员函数和（函数定义体）：任何不会修改数据成员的函数都应用const修饰，这样，当不小心修改了数据成员或调用了非const成员函数时，编译器会保错。

```c++
const 修饰类的成员函数形式：
    int GetCount(void)const;
```



###### 2.描述char *、const char *、char * const、const char* const的区别?

（1）：const char * s 是指向常量的指针，*s是不变的，s是可以改变的，

（2）：char * const s, 定义一个指向字符的指针常数，既const指针，不能修改s指针，但是可以修改指向的内容。

（3）：const char *const s,定义一个指向常量的常量指针，不能修改s指向的指针，也不能修改指向的内容。

###### 3.指针常量和常量指针有什么区别？

指针常量是指指针本身是常量，换句话说，就是指针里面所存储的内容（内存地址）是常量，不能改变，但是地址所对应的内容是可以通过指针进行修改。

```c
int main()
{
    int a = 1;
    int b = 2;
    int *const p = &a;
    *P =2;
    p = &b; //错误
}
```

常量指针就是指向常量的指针，换句话说，就是指针指向的是常量，它指向的内容不能被修改，但是指针本身可以被修改，指向另一个常量。

```c
int main()
{
    int a = 1;
    int b = 2;
    int const *p = &a; //正确
    p = &b; //正确
    *p= 2;//错误
}
```

###### 4.static的作用是什么，什么情况下用到static？

一、隐藏

当我们同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。

二、保持变量内容的持久

存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化，全局变量和static变量都是在静态存储区。

三、默认初始化为0

在静态数据区，内存中默认值都是为0x00,。

四、

在函数体内，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。

在模块内（函数体外），一个被声明为静态的变量可以被模块内所有函数访问，但不能被模块外其他函数访问。

静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；

（1）全局变量前面加上static

​	在生命期方面，它与一般全局变量一样，是与整个程序共存亡的

​	在可见性方面，它只定义在它的编译单元中可见，比如在testA.c中定义了一个全局变量，你只能在testA.c的函数中引用它，在另一个文件testB.c中如果想用它的话：extern int x;会引发错误

（2）在函数前面加上static

​	与静态全局变量差不多，在testA.c中定义的静态函数：static void A(void)是不能在testB.c中使用。

static的用途：一般对那些非接口函数和确定外部不使用的全局变量加上static限制，可以保证不会被其他编译单元非法使用，同时也可以避免与别的编译单元中的同名符号冲突。在驱动程序中用的较多。

###### 5.全局变量与局部变量的区别？

1）作用域不同：全局变量的作用域为整个程序，为局部变量的作用域为当前函数或循环等

2）内存存储方式不同：全局变量存储在全局数据区，也就是占用静态的存储单元，局部变量存储在栈区，只有所在函数被调用时才动态的为变量分配存储单元。

3）生命期不同：全局变量的生命期和主程序一样，随程序的销毁为销毁，局部变量随函数的退出或循环退出就不存在了。

4）使用方式不同：全局变量在声明后程序的各个部分都可以用到，但是局部变量只能在局部使用，函数内部会优先使用局部变量再使用全局变量。局部变量和全局变量重名后，会屏蔽全局变量。

5）全局变量是可以被本程序所有对象或函数引用。

###### 6.宏定义的作用是什么？

1）使用宏定义常量

#define MAXSIZE 200

```c
#include <stdio.h>
#define M 20
int main()
{
    int a = M;
    //编译后代码：int a = 20;
    return 0;
}
```

const也可以用来定义常量，区别在哪

（1）const定义常量需要指出类型，宏定义不用，宏定义是简单的替换，不会进行安全检查，但是可能会产生边界效应。

```c
#define N 100
#define M N+300
//在程序中使用M*N, 则结果会是100+300*100；原因在于定义M时是N+300,而不是（M+300）
```

（2）当定义局部变量时，const所定义的变量的作用域，仅限于const所定义在的函数段，而定义#define，其作用域不仅限于在定义的函数段，而是从定义点到整个程序的结束。

（3）const定义的常量在编译时会为该变量分配存储空间，而宏定义是在预编译时编译，不分配存储空间。

2）防止多重包含

预处理器变量：在编写头文件时，避免重复包含

```
#ifndef _HEAD_H_
#define _HEAD_H_
#endif
```

3)条件编译

在C语言中，预处理过程读入源代码，检查包含预处理指令的语句和宏定义，并对源代码进行相应的转换，预处理过程还会删除程序中的注释和多余的空白符号。预处理指令是以#开头的代码行，条件编译的用法与使用宏防止多重引用类似

ifdef _DEBUG//如果定义了 _DEBUG,则执行#ifdef _DEBUG与#else之间的指令；

cout<<"debug"<<

else//否则，执行#else与#endif之间的指令

cout<<"release"<<

endif

4）宏函数

函数的调用是需要一定的时间和空间代价的。宏函数则不存在上述问题，宏函数在预编译时，同函数定义的代码来替换函数名，将函数嵌入到当前程序，不会产生函数调用，所以省去普通函数保留现场恢复现场的时间，但会多占用额外的存储空间

#define MAX(a,b) ((a)<(b)?(b):(a))

需要注意inline标识符。inline也将函数定义为内联的。但是内联函数体不能含有循环，条件，选择等复杂结构，否则就不能作为内联函数了。

5）宏组合 #和##

```c++
#include "stdio.h"
#include <iostream>

#define s5(a) Connect_##a
#define s(p)	#p

void Connect_Test(const char*P)
{
	cout<<"this is connect test"<<endl;
	cout <<p<<endl;
}

int main()
{
	s5(Test)("hello world");
	cout<<"---------------"<<endl;
	cout<<s(c)<<endl;
	return 0;
}
//输出this is connect test
//hello world
//--------------------
//c
```

##是连接符号，用来连接两个宏， #的作用是将后面的宏参数进行转化为字符串

当宏参数中有#或者##的地方，宏参数不会被展开



###### 7.内存对齐的概念？为什么会有内存对齐？

因为访问特定变量的时候需要在特定的内存地址访问，就需要各类型数据按照一定的规则在空间上排列。

对齐规则，其偏移量为成员大小的整数倍，最后结构体的大小为最大成员的整数倍。

为什么要内存对齐？

1）平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上 的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。

2）性能原因：数据结构（尤其是栈）应该

###### 8.inline 内联函数的特点有哪些？它的优缺点是什么？

优点：

1）内联函数被放入符号表中，使用时像宏一样替换，效率高。

2）编译会检查参数问题，保证调用正确，消除了隐患和局限性

3）inline可以作为类的成员函数，可以使用所在类的保护成员及私有成员。（类中定义的函数不管加不加inline都会是内联函数）

缺点：

1）以函数复制为代价，如果过多使用，会销毁内存

2）如果函数体内有循环，那么执行函数代码时间比调用开销大。

###### 9.如何用C 实现 C++ 的面向对象特性（封装、继承、多态）

结构体+函数指针

```c
#include <stdio.h>
#include <stdlib.h>

typedef void(*FUNC)();
typedef struct Base{
    FUNC _func;
}Base;

typedef struct Derived{
    Base _base;
}Derived;

void _funcB(){
	printf("Base._func().\n");
    return;
}

void _funcD(){
    printf("Derived._func().\n");
    return;
}

void test(){
    Base base;
    Derived derived;
    
    base._func = _funcB;
    derived._base._func = _funcD;
    
    Base*pBase = &base;
    pBase->_func();
    
    pBase = (Base*)&derived;
    pBase->_func();
    return;
}
```

###### 10.memcpy怎么实现让它效率更高?

```c
void *mymemcpy(void *dst,const void *src,size_t num)
{
    assert((dst>=src+num)||(src>dst+num));
    byte *psrc = (byte*)src;
    byte*pdst = (byte*)dst;
    while(num-->0) *pdst++=*psrc++;
    return dst;
}


void * mymemcpy(void *dest, const void *src, size_t count)  
{  
    if (dest == NULL || src == NULL)  
          return NULL;  
    char *pdest = static_cast <char*>(dest);  
    const char *psrc  = static_cast <const char*>(psrc);  
    int n = count;  
      
    if (pdest > psrc && pdest < psrc+count)  
    {  
        for (size_t i=n-1; i != -1; --i)  
        {  
                pdest[i] = psrc[i];  
        }  
    }  
    else  
    {  
        for (size_t i= 0; i < n; i++)  
        {  
                pdest[i] = psrc[i];  
        }  
    }  
      
    return dest;  
}  
```

###### 11.typedef和define有什么区别？

1）原理不同

**#define是C语言中定义的语法**，**是预处理指令**，在预处理时进行简单而机械的字符串替换，<u>不作正确性检查</u>，只有在编译已被展开的源程序时才会发现可能的错误并报错。

**typedef是关键字**，**在编译时处理，有类型检查功能**。它在自己的作用域内给一个已经存在的类型一个别名，但不能在一个函数定义里面使用typedef。用typedef定义数组、指针、结构等类型会带来很大的方便，不仅使程序书写简单，也使意义明确，增强可读性。

2）功能不同

typedef用来定义类型的别名，起到类型易于记忆的功能。另一个功能是定义机器无关的类型。

\#define不只是可以为类型取别名，还可以定义常量、变量、编译开关等。

3）作用域不同

\#define没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，而typedef有自己的作用域。

4）对指针的操作不同

```c
#define INTPTR1 int*

typedef int* INTPTR2;

INTPTR1 p1,p2;     //声明一个指针变量p1和一个整型变量p2

INTPTR2 p3,p4;		//声明两个指针变量p3、p4

#define INTPTR1 int *
typedef int* INTPTR2;
const INTPTR1 p1;    //常量指针，指针指向的值不可以被更改，指针本身可以被修改
const INTPTR2 p2;	//指针常量，指针的值不能被修改，可以修改解引用的值


```

###### 12.extern有什么作用，extern C有什么作用？

一个c文件需要调用另一个c文件的变量或者函数，而不能从.h文件中调用变量。

对于函数而言，和引用变量是一样的，如果需要调用其他.c文件中的函数，在文件中的函数声明前加extern即可，不加extern而直接声明函数也可以，因为声明全局函数默认前面带有extern。

extern int a = 5与int a = 5意义是一样的，都是定义。而extern int a;是声明。

如果不想让其他.c文件引用本文件中的变量，加上static即可。

extern int  a; 仅仅是一个变量的声明，并不是在定义变量a，并未分配空间。



extern "C"的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern "C"后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，**因此编译C语言代码的函数时不会带上函数的参数类型**，一般之包括函数名。


extern C是由C++提供的一个连接交换指定符号，用于告诉C++这段代码是C函数，因为C++编译后库中函数名会变得很长，与C生成的不一致，造成C++不能直接调用C函数，加上extern C之后，就能直接调用C函数。

###### 13.如何避免野指针？

野指针：随机指向内存中的一个地址，对于这个地址不一定有访问权，会导致内存泄漏。

```c
#include <stdio.h>
#include <stdlib.h>
//#define NULL (void *)0  //(void *0) 是0地址，是不允许操作，不允许访问的。
#define MAX_SIZE sizeof(char) * 100
//memset  bzero

int main()
{
    char *ptr = (char *)malloc(MAX_SIZE);//必须是相同类指针类型赋值，否则有可能会越界。

    if(NULL == ptr)
    {
        printf("malloc error!\n");
        exit(1);
    }

    //memset(ptr,0,MAX_SIZE);
    bzero(ptr,MAX_SIZE);
    
    scanf("%s",ptr);
    
    printf("ptr = %s\n",ptr);
    
    free(ptr);
    
    ptr = NULL;
}
```

1）当指针没有初始化时，将指针指为NULL。

初始化为NULL的目的：一是出现段错误时易改错，二是（void*0）是0地址，是不允许操作，不允许访问的

2）当给指针赋值时，检查是否已经给它分配了内存空间，如果没有，再用malloc分配

3）给指针分配完内存后，不使用时再用free()函数清空内存空间，并再降指针指为NULL。

注释：void*为万能指针，可以接收任何类型的指针，但是不能对其取值（不能对它指向的空间进行操作，它只能暂时存放地址）

###### 14.如何计算结构体长度？

sizeof()

offsetof函数可以得到结构体成员相对于结构体首地址的偏移量。

默认对齐方式下：

1. 结构体第一个成员的地址和结构体的首地址相同
2. 结构体每个成员地址相对于结构体首地址的偏移量（offset）是该成员大小的整数倍，如果不是则编译器会在成员之间添加填充字节（internal adding）。
3. 结构体总的大小要是其成员中最大size的整数倍，如果不是编译器会在其末尾添加填充字节（trailing padding）。

###### 15.sizeof和strlen有什么区别？

1）sizeof操作符的结果类型是size_t，在头文件中的typedef为unsigned int类型

2）sizeof是运算符，strlen是函数

3）sizeof可以用类型作参数，strlen只能用char*做参数，且必须是以“\0”结尾的，sizeof还可以用函数做参数。

4）数组做sizeof的参数不退话，传递给strlen就退化为指针

5）大部分编译程序在编译的时候就把sizeof计算过了，是类型或是变量的长度。这就
是sizeof(x)可以用来定义数组维数的原因

6）strlen的结果要在运行的时候才能计算出来，用来计算字符串的长度，而不是类型占内存的大小

7）sizeof后如果是类型必须加括号，如果是变量名可以不加括号，因为是操作符不是函数

8）当使用了一个结构类型或变量时，sizeof返回实际的大小。当使用一静态的空间数
组时，sizeof返回全部数组的尺寸。sizeof操作符不能返回被动态分配的数组或外部的数组的
尺寸。

9）数组作为参数传给函数时传的是指针而不是数组，传递的是数组的首地址，如
fun(char ［8］)、fun(char [])都等价于fun(char *)。在C++里传递数组永远都是传递指向数组首元素的指针，编译器不知道数组的大小。如果想在函数内知道数组的大小，需要这样做：进入函数后用memcpy将数组复制出来，长度由另一个形参传进去

10）sizeof操作符不能用于函数类型、不完全类型或位字段。不完全类型指具有未知
存储大小数据的数据类型，如未知存储大小的数组类型、未知内容的结构或联合类型、void类型等。

11）算结构变量的大小就必须讨论数据对齐问题。为了使CPU存取的速度最快（这
同CPU取数操作有关，详细的介绍可以参考一些计算机原理方面的书），C++在处理数据时经常把结构变量中的成员的大小按照4或8的倍数计算，这就叫数据对齐（data alignment）。这样做可能会浪费一些内存，但在理论上CPU速度快了。当然，这样的设置会在读写一些别的应用程序生成的数据文件或交换数据时带来不便。MS VC++中的对齐设定，有时候sizeof得到的与实际不等。一般在VC++中加上#pragma pack(n)的设定即可。或者如果要按字节存储，而不进行数据对齐，可以在Options对话框中修改Advanced Compiler选项卡中的“DataAlignment”为按字节对齐。

###### 16.知道条件变量吗？条件变量为什么要和锁配合使用？

条件变量本身不是锁，但它可以造成线程阻塞。通常与互斥锁配合使用。给多线程提供一个会和的场所。

条件变量可以减少竞争。

mutex体现的是一种竞争，我离开了，通知你进来

cond体现的是一种协作，我准备好了，通知你开始吧。

减少CPU的浪费。

条件变量利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：一个线程等待"条件变量的条件成立"而挂起；另一个线程使“条件成立”。为了防止竞争，条件变量的使用总是和一个互斥锁结合在一起。线程在改变条件状态前必须首先锁住互斥量，函数pthread_cond_wait把自己放到等待条件的线程列表上，然后对互斥锁解锁(这两个操作是原子操作)。在函数返回时，互斥量再次被锁住。


第一点，**首先我们要理解条件变量的作用是在等待某个条件达成时自身要进行睡眠或阻塞，避免忙等待带来的不必要消耗**，所以**条件变量的作用在于同步**。条件变量这个变量其实本身不包含条件信息，条件的判断不在pthread_cond_wait函数功能中，而需要外面进行条件判断。**这个条件通常是多个线程或进程的共享变量**，这样就很清楚了，**对于共享变量很可能产生竞争条件尤其还对共享变量加了条件限制**，所以从这个角度看，**必须对共享变量加上互斥锁**。

　　第二点，pthread_cond_wait这个函数的过程我们必须了解，首先对互斥锁进行解锁（条件判断不属于函数的功能），解锁之后自身睡眠等待条件达成，注意这时候函数并未返回，因为还缺少一步，待条件完成后重新加锁。pthread_cond_wait提供的重要功能是保证这两个操作一定是原子操作不可分割。试想一下，如果进程A调用了pthread_cond_wait，先进行了解锁，这时候由于进程A时间片到期，轮换到进程B，进程B一直想要这把锁，现在终于拿到了，它干完了事情，调用pthread_cond_signal想唤醒A但是A并未完成睡眠等待条件达成，所以这个唤醒信号就丢失了。

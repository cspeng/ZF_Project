# 设计模式

###### 1.分别写出饿汉和懒汉线程安全的单例模式

1）懒汉式单例

```c++
#include <iostream>
#include <thread>

using namespace st;

class Singleton{
    public:
    	static Singelton*GetSingleton();
    private:
    	Singelton(){}
		static Singelton*single;
};
Singleton* Singleton::single = nullptr;
Singleton * Singelton::GetSingleton(){
    if(single==nullptr){
        single = new Singleton;
    }
    return single;
}

int main(int argc,char*argv[]){
    Singleton*s1 = Singelton::GetSingleton();
    Singleton*s2 = Singelton::GetSingleton();
    if(s1==s2){
        cout<<"s1==s2"<<endl;
    }else{
        cout<<"s1!=s2"<<endl;
    }
    return 0;
}
```

C++的构造函数不是线程安全的，所有上述代码在多线程的情况下是不安全的，原因是new Singleton时，这句话不是安全的，比如一个线程执行了new的同时，另一个线程执行了判断（此时单例还没被创建出来）

懒汉式在于真正需要a时，调用getInstance才创建出唯一实例。这可以看成一个具有拖延症的单例模式，不到最后关头不干活。很多设计都体现了这种拖延的思想，比如string的写时复制，真正需要的时候才分配内存给string对象管理的字符串。

2）懒汉的线程安全问题

```c++
class Singleton{
    public:
    	static Singleton*GetSingleton(){
            if(p==NULL){
                pthread_mutex_lock(&mutex);
                if(p==NULL){
                    p = new Singleton;
                }
                pthread_mutex_unlock(&mutex);
            }
            return p;
        }
    private:
    	Singleton(){
            pthread_mutex_init(&mutex,NULL);
        }
    	static Singleton*p;
    	static pthread_mutex_t mutex;
};
pthread_mutex_t Singleton::mutex;
singleton*singleton::p = NULL;
```



3）饿汉式

饿汉单例，即在最开始的时候，静态对象就已经创建完成；
设计方法是类中包含一个静态成员指针，该指针指向该类的一个对象，提供一个公有的静态成员方法，返回该对象指针；为了使得对象唯一，还需要将构造函数设为私有

```c++
class Singleton{
    public:
    	static Singleton*GetSingleton(){
            return single;
        }
    private:
    	Singleton(){};
    	static Singleton*single;
};
Singleton* Singleton::single = new Singleton;
int main(){
    /*我们注意到，在刚进入main函数，我们就打印了一句“”main begin“”，为什么要在这里加入一句输出语句呢？
	因为我们此时的单例模式采用的是饿汉单例，所以，哪怕你还没用到我这个对象，我也会先创建一个出来，
	先占着，即所谓的饿汉，其实就是类似于全局变量的构造是在进入main函数之前的原理，*/
	cout<<"main begin"<<endl; //验证静态对象的创建在main之前。
    Singleton *s1 = Singleton::GetSingleton();
    Singleton *s2 = Singleton::GetSingleton();
    if(s1==s2){
        cout<<"s1==s2"<<endl;
    }else{
        cout<<"s1!=s2"<<endl;
    }
    sysetm("pause");
    return 0;
}
```

这里把class A构造函数都设置为私有，不允许用户代码创建对象。要获取对象实例需要通过接口getInstance.饿汉式的缺点在于无论有没有代码需要a,a都被创建出来。



单例模式的适用场景 
（1）系统只需要一个实例对象，或者考虑到资源消耗的太大而只允许创建一个对象。 
（2）客户调用类的单个实例只允许使用一个公共访问点，除了该访问点之外不允许通过其它方式访问该实例 (就是共有的静态方法)。 



###### 2.说出观察者模式类关系和优点

建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者、

观察者模式：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。

结构：

- **Observer：抽象观察者**，是观察者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。
- **ConcrereObserver：具体观察者**，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。
- **Subject：抽象主题（抽象被观察者）**，抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。
- **ConcreteSubject：具体主题（具体被观察者）**，该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。

**观察者模式适用情况**

（1）当一个对象的数据更新时需要通知其他对象，但这个对象又不希望和被通知的那些对象形成紧耦合。

（2）当一个对象的数据更新时，这个对象需要让其他对象也各自更新自己的数据，但这个对象不知道具体有多少对象需要更新数据。

优点：降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。

​			被观察者发送通知，所有注册的观察者都会收到信息[可以实现广播机制]

缺点：

​			如果观察者非常多的话，那么所有的观察者收到被观察者发送的通知会耗时。

​			如果被观察者有循环依赖的话，那么被观察者发送通知会使观察者循环调用，会导致系统崩溃。

###### 3.说出代理模式类关系和优点

![image-20210625232646210](C:\Users\10594\AppData\Roaming\Typora\typora-user-images\image-20210625232646210.png)

定义：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中间的作用。

代理模式的角色：

- ISubject：代理者与被代理者共同实现的接口，可以理解为需要代理的行为；

- SubjectImpl：被代理者，其为具有某种特定行为的实现者；

- SubjectProxy：代理者，其会全权代理SubjectImpl所具有的功能，在实现其功能的基础上做一些额外的工作；

- Client：客户端，客户端访问代理者与访问被代理者具有类似的效果，其无法区分访问的是代理者还是被代理者。

  ```c++
  #include <iostream>
  using namespace std;
  
  class AbstractCommonInterface{
      public:
      	virtual void run()=0;
      	virtual ~AbstractCommonInterface(){}
  };
  
  class MySystem:public AbstractCommonInterface{
      virtual void run(){
          cout<<"系统启动"<<endl;
      }
      ~MySystem(){}
  };
  class MySystemProxy:public AbstractComonInterface{
      public:
      	MySystemProxy(string name,string password):mUsername(name),mPassword(password){
              pSystem = new MySystem;
          }
      	bool CheckNameAndPassword(){
              if(this->mUsername=="admin"&&this->mPassword=="admin"){
                  return true;
              }
              return false;
          }
      	virtual void run(){
              if(CheckNameAndPassword){
                  cout<<"right"<<endl;
                  pSystme->run();
              }else{
                  cout<<"error"<<endl;
              }
          }
      private:
      	MySystem *pSystem;
      	string mUsername;
      	string mPassword;
  };
  
  int main(int argc,char*argv[]){
      MySystemProxy*system = new MySystemProxy("admin","admin");
      system->run();
      delete system;
      return 0;
  }
  ```

  

###### 4.说出工厂模式概念和优点

工厂模式去代替直接实例化对象是为了**可复用，并且可以实现模块间的解耦。**

分为简单工厂、工厂方法、抽象工厂模式

简单工厂：传入不同的参数来实现多态，达到实例化不同对象的目的。

```c++
class AbstractFruit{
    virtual show_name=0;
};
class AppleFruit:public AbstractFruit{
  	virtual show_name(){
        cout<<""<<endl;
    }  
};
class Banana:public AbstractFruit{
    virtual show_name(){
        cout<<""<<endl;
    }
};
class FactoryFruit{
    public:
    	AbstractFruit* create_fruit(string name){
            if(name =="apple"){
                return new AppleFruit;
            }else if(name == "banana"{
                return new AppleFruit;
            }
        }
};
int main(int argc,char*argv[]){
	FactoryFruit *factory = new FruitFactory;
    AppleFruit *apple = factory->create_fruit("apple");
    apple->showname();
    delete apple;
    delete factory;
    return 0;
}
```

工厂模式：对简单工厂模式多了一层抽象，将实例化某一类对象，具体细分给对应的工厂，而不是在一个工厂里通过依赖参数。

```c++
class AbstractFruit{
    virtual show_name=0;
    virtual ~AbstractFruit(){};
};
class AppleFruit:public AbstractFruit{
  	virtual show_name(){
        cout<<""<<endl;
    }  
};
class BananaFruit:public AbstractFruit{
    virtual show_name(){
        cout<<""<<endl;
    }
};
class FruitFactory{
    virtual AbstractFruit*createFruit()=0;
    virtual ~FruitFactory(){};
};
class AppleFactory:public FruitFactory{
  	virtual AbstractFruit*createFruit(){
        return new AppleFruit;
    }  
};
class BananaFactory:public FruitFactory{
  	virtual AbstractFruit*createFruit(){
        return new BananaFruit;
    }
};
int main(int argc,char*argv[]){
    FruitFactory *factory  = new AppleFactory;
    AbstractFruit * fruit = factory->createFruit();
    fruit->show_name();
    delete factory;
    delete fruit;
    factory = new BananaFactory;
    fruit = factory->createFruit();
    fruit->show_name();
    delete factory;
    delete fruit;
    return 0;
}
```

抽象工厂模式：是对工厂模式又进行了一层抽象，不单单是像工厂模式只生成一类产品，而是一系列产品，并且可以像零件一样灵活配置给各个工厂。

```c++
class AbstractApple{
  	virtual void showName=0;
    virtual ~AbstractApple(){};
};
class AbstractBanana{
 	virtual void showName=0;
    virtual ~AbstractBana(){};
};
class ChinaApple:public AbstractApple{
    public:
    	virtual void showName(){
            cout<<""<<endl;
        }
};
class JapanApple:public AbstractApple{
    public:
    	virtual void showName(){
            cout<<""<<endl;
        }
};
class ChinaBana:public AbstractApple{
    public:
    	virtual void showName(){
            cout<<""<<endl;
        }
};
class JapaBanana:public AbstractApple{
    public:
    	virtual void showName(){
            cout<<""<<endl;
        }
};

class AbstractFactory{
    public:
    	virtual AbstractApple*createApple()=0;
    	virtual AbstractApple*createBanana()=0;
    	virtual ~AbstractFruitFactory(){}
};
class ChinaFactory:public AbsractFactory{
  public:
    virtual AbstractApple*createApple(){
        return new ChinaApple;
    }
    virtual AbstractBanana *createBanana(){
		return new ChinaBanana;
    }
};
class JapanFactory:public AbsractFactory{
  public:
    virtual AbstractApple*createApple(){
        retur new JapanApple;
    }
    virtual AbstractBanana*createBanana(){
        retur new JapanBanana;
    }
};
int main(int argc,char*argv[]){
    AbstractApple *fruit = NULL;
    AbstractFactory *factory = NULL;
    AbstractBanana *banana=NULL;
    
    factory = new ChinaFactory;
    fruit = factory->createApple();
    fruit->showName();
    delete fruit;
    delete factory;
    factory = new JapanFactory;
    banana = factory->createBanana();
    delete factory;
    delete banana;
    return 0;
}
```

一、简单工厂模式 【优点】：1、客户端创建对象时只需要记住特定的参数，而不需要记住复杂的类名，也不用关注实现的过程。(实现了封装和部分解耦)

​                            2、创建对象不需要单独实例化，而是通过工厂类直接获取示例(实现复用)

​                   【缺点】：1、实例化对象的逻辑全部封装在一个工厂类里，每次需求变化都要单独修改工厂类(违反了开闭原则)，而且出了异常可能没法正常工作。

​                            2、不方便扩展子类

　　　　　　　　　　【应用场景】：适合业务简单或者产品较少的情况

​    二、工厂模式    【优点】：1、在简单工厂的基础上遵循了开闭原则，又进行了解耦，工厂类分为具体的工厂类

​                  【缺点】：1、每增加一个工厂，就要额外开发一个工厂

​                  【应用场景】：正文中符合工厂模式的情况，多由于解耦

​    三、抽象工厂模式  【优点】：1、正是由于复杂的抽象关联关系使得在类的内部对一系列产品组的管理很方便

​                    【缺点】：1、扩展很费力，每次要修改很多类。

​                    【应用场景】：待创建的对象是一系列相互关联或相互依赖的产品族时

###### 5.说出构造者模式概念

将一个复杂对象的构造与它的表示分离，使得同样的构造过程可以创建不同的表示。

表现形式：链式调用。

1.定义一个静态内部类Builder,内部的成员变量和外部类一样

2.Builder类通过一系列的方法用于成员变量的赋值，并返回当前对象本身（this)

3.Builder类提供一个build方法或者create方法用于创建对应的外部类，该方法内部调用了外部类的一个私有构造函数，该构造函数的参数就是内部类Builder

4.外部类提供一个私有构造函数供内部类调用，在该构造函数中完成成员变量的赋值，取值为Builder对象中对应的值。

```c++
/*
 * @Author: your name
 * @Date: 2021-06-25 21:50:54
 * @LastEditTime: 2021-06-25 22:33:09
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \vs_code_c++\C++_test\build_mode.cpp
 */
#include <iostream>
#include <string>
using namespace std;

class Person{
    public:
    	 class Builder{
             friend class Person;

         public:
             Builder setId(int id)
             {
                 this->id = id;
                 return *this;
                }
                Builder setName(string name){
                    this->name = name;
                    return *this;
                }
            
                Builder setSex(string sex){
                    this->sex =sex;
                    return*this;
                }

                Builder setHeight(int height){
                    this->height = height;
                    return *this;
                }

                Builder setOccupation(string occupation){
                    this->occupation = occupation;
                    return *this;
                }
            	Person* build(){
                    return new Person(*this);
                }
            private:
                 int id;
                string name;
                string sex;
                int height;
                string occupation;
                static const string TAG;
                };
    private:
        int id;
        string name;
        string sex;
        int height;
        string occupation;
        static const string TAG;
    private:
    	Person(Builder builder){
            this->id = builder.id;
            this->name = builder.name;
            this->sex= builder.sex;
            this->height = builder.height;
            this->occupation = builder.occupation;
        }    
    public:
    	int getId(){
            return id;
        }
    	void setId(int id){
            this->id = id;
        }
    	string getName(){
            return name;
        }
    	void setName(string name){
            this->name = name;;
        }
    	string getSex(){
			return sex;
        }
    	void setSex(string sex){
            this->sex =sex;
        }
    	int getHeight(){
            return height;
        }
    	void setHeight(int height){
            this->height = height;
        }
    	string getOccupation(){
            return occupation;
        }
    	void setOccupation(string occupation){
            this->occupation = occupation;
        }
    
        
   
};
const string Person::TAG = "Person";
int main(int argc,char*argv[]){
    Person::Builder *b = new Person::Builder;
    Person *p1 = b->setId(1).setHeight(110).build();
    cout << p1->getId();
    system("pause");
    return 0;
}
```



###### 6.说出适配器模式概念

```c++
//适配器模式，将已经写好的接口转化为目标接口
class MyPrint{
    public:
    void operator()(int v1,int v2){
        cout << v1 + v2 << endl;
    }
};
class Target{
    public:
        virtual void operator()(int v) = 0;
};
class Adapter:public Target{
    public:
        Adapter(int param){
            this->param = param;
        }
        virtual void operator()(int v){
            myprint(v, param);
        }
    public:
        MyPrint myprint;
        int param;
};
Adapter My2Bind(int v){
    return Adapter(v);
}
int main(int argc,char*argv[])
{
    vector<int>v;
    for (int i = 0; i < 10;i++){
        v.push_back(i);
    }
    for_each(v.begin(), v.end(), My2Bind(10);
    system("pause");
    return 0;
}
```

定义：让原来不兼容的两个接口协同工作

分类：类适配器、对象适配器、接口适配器

角色：

- 目标接口：Target,该角色把其他类转换为我们期望的接口
- 被适配者：Adaptee原有的接口，也是希望被改变的接口
- 适配器：Adapter,将被适配者和目标接口组合到一起的类

**适配器好处**

- 重用
  - 复用的现存的类, 解决了现存类和复用环境要不一致的问题
- 低耦合
  - 无需修改原有代码（遵循开闭原则）
# 编译原理

###### 1. gcc hello.c 这行命令具体的执行过程，内部究竟做了什么？

```c
#include <stdio.h>

int main(){
	printf("Hello tomorrow");
	return 0;
}
```

编译运行

```
$ gcc test.cc
$ ./a.out
Hello tomorrow
```

![image-20210626003958019](C:\Users\10594\AppData\Roaming\Typora\typora-user-images\image-20210626003958019.png)

gcc编译程序经历：预处理->编译->汇编->链接

首先使用file看一下test.cc文件类型：

```
$ file test.cc
test.cc:C source,UTF-8 Unicode text,with CRLF line terminators
```

预处理

```
$ gcc -E test.cc -o test.i
或者
$ cpp test.cc -o test.i
```

再看下test.i的文件类型

```
$ file test.i
test.i:C source, UTF-8 Unicode text
```

这里可以看出预处理后的文件和预处理前的文件类型是相同的，都是文本文件，也可以直接查看test.i的内容，里面代码较多，就不贴上来了。

其实预处理主要操作有这几个:

- 展开所有#define宏定义，进行文本替换
- 删除程序中的注释
- 处理所有条件编译，#if,#ifdef,#elif...
- 处理所有#include指令，把这些头文件的内容复制到引用的源文件中
- 添加行号和文件名标识，方便编译器产生警告及调试信息
- 保留所有的#pragma编译器指令，因为编译器会使用它们

编译

```
$ gcc -S test.cc -o test.s
```

```
$ file test.s
test.s: assembler source,ASCII test
```

![image-20210626004915054](C:\Users\10594\AppData\Roaming\Typora\typora-user-images\image-20210626004915054.png)

如图二，编译过程就是把预处理后的文件进行一系列操作生成相应的汇编文件：

1. 词法分析：又称词法扫描，通过扫描器，利用有限状态机的算法将源码中的字符串分割成一系列记号，如加减乘除数字括号等。
2. 语法分析：使用语法分析器对词法分析产生的记号运用上下文无关语法的手段进行语法分析，产生语法分析树。这期间如果表达式不合法（括号不匹配等），就会报错。
3. 语义分析：语法分析检查表达式是否合法，语义分析检查表达式是否有意义，如浮点型整数赋值给指针，编译器就会报错。
4. 中间语言生成：做一些语法树优化，如6+2=8。
5. 目标代码生成及优化：将中间代码生成目标汇编代码。

汇编

```
$ gcc -c test.s -o test.o
或
$ as test.s -o test.o
```

```
$ file test.o
test.o: ELF 64-bit LSB relocatable, x86-64, versin 1 (SYSV),not stripped
```

使用汇编器将汇编代码转成机器可以执行的指令，其实就是将汇编指令和机器指令按照对照表一一翻译。

链接

为什么汇编器不直接生成可执行文件而是生成一个目标文件呢，因为一个文件需要依赖其它好多个库，这些库的符号需要通过链接过程才可以互相配合生成一个可执行文件，需要经历地址和空间分配、符号决议、重定位等步骤，这块内容较多，后续会详细介绍，现在我们可以简单的通过ldd查看一下可执行程序需要依赖的库，这些库都需要在链接过程中被链接才可以使用。

```
$ ldd a.out

linux-vdso.so.1 (0x00007ffff5b4a000)
libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fa1fc660000)
/lib64/ld-linux-x86-64.so.2 (0x00007fa1fce00000)
```



###### 2.程序一定会从main函数开始运行吗？

对于静态链接先提出两个问题：

Q:

每个目标文件都有好多个段，目标文件在被链接成可执行文件时，输入目标文件中的各个段如何被合并到输出文件？

A:

合并相似的段，将所有的.text段合并到输出文件的.text段，将所有的.data段合并到输出文件的.data段

Q:

链接器如何为他们分配在输出文件中的空间和地址？

A:

这里涉及到程序链接的两个步骤：

1. 空间与地址分配：扫描所有的输入目标文件，获得它们每个段的长度属性和位置，收集输入目标文件中的符号表中的所有符号定义和符号引用，统一放到一个全局符号表中，合并所有的段，计算出输出文件中各个段合并后的长度和位置，并建立映射关系。
2. 符号解析与重定位：使用第一步收集到的所有信息，读取输入文件中段的数据及重定位信息，进行符号解析和重定位，调整代码中的地址，将每个段中需要重定位的指令和数据进行“修补”，使他们都指向正确的位置。

tips：外部符号指的是目标文件需要引用的符号，但是定义在其它目标文件中，链接前外部符号地址都是000000之类，链接后的可执行文件就可以看见这些外部符号都是有地址的。链接就是把相似的段放在一起，先找到段的偏移地址，再找出符号在段中的偏移，这样可以确定符号在整个可执行程序中的地址。

对于那些需要重定位的符号，都会放在重定位表里，也叫重定位段，即.rel.data、.rel.text等，如果.text段有被重定位的地方，就有.rel.text段，如果.data段有被重定位的地方，就有.rel.data段。可以使用objdump查看目标文件的重定位表。

```
int main(){
	printf("hello tomorrow");
	return 0;
}
gcc -c test

objdupm -r test.o
test.o:     file format elf64-x86-64

RELOCATION RECORDS FOR [.text]:
OFFSET           TYPE              VALUE
0000000000000007 R_X86_64_PC32     .rodata-0x0000000000000004
000000000000000c R_X86_64_PLT32    puts-0x0000000000000004


RELOCATION RECORDS FOR [.eh_frame]:
OFFSET           TYPE              VALUE
0000000000000020 R_X86_64_PC32     .text

使用nm也可以查看需要重定位的符号：
nm -u test.o
                 U _GLOBAL_OFFSET_TABLE_
                 U puts

```

对于UND类型，这种未定义的符号都是因为该目标文件中有关于他们的重定位项，在链接器扫描完所有的输入目标文件后，所有这种未定义的符号都应该能在全局符号表中找到，否则报符号未定义错误。

注意：我们代码里明明用的是printf，为什么它却引用了puts的符号呢，因为编译器默认情况下会把只用一个字符串参数的printf替换成puts， 可以节省格式解析的时间，使用-fno-builtin会关闭这个内置函数优化选项，如下：

```
~/test$ gcc -c -fno-builtin testlink.cc -o test.o
~/test$ nm test.o
                 U _GLOBAL_OFFSET_TABLE_
0000000000000000 T main
                 U printf
```

tips：现在的程序和库通常来讲都很大，一个目标文件可能包含成百上千个函数或变量，当需要用到某个目标文件的任意一个函数或变量时，就需要把它整个目标文件都链接进来，也就是说那些没有用到的函数也会被链接进去，这会导致链接输出文件变的很大，造成空间浪费。

有一个编译选项叫函数级别链接，可以使得某个函数或变量单独保存在一个段里面，都链接器需要用到某个函数时，就将它合并到输出文件中，对于没用到的函数则将他们抛弃，减少空间浪费，但这会减慢编译和链接过程，GCC编译器的编译选项是：

```
-ffunction-sections
-fdata-sections
```

可能很多人都会以为程序都是由main函数开始执行和结束的，但其实不是，在main函数调用之前，为了保证程序可以顺利进行，要先初始化进程执行环境，如堆分配初始化、线程子系统等，C++的全局对象构造函数也是这一时期被执行的，全局析构函数是main之后执行的。

Linux一般程序的入口是__start函数，有两个段：

- .init段：进程的初始化代码，一个程序开始运行时，在main函数调用之前，会先运行.init段中的代码。
- .fini段：进程终止代码，当main函数正常退出后，glibc会安排执行该段代码。

如何指定程序入口

在ld链接过程中使用-e参数可以指定程序入口，由于一段简短的printf函数其实都依赖了好多个链接库，我们也不太方便使用链接脚本将目标文件与所有这些依赖库进行链接，所以使用下面这段内嵌汇编的程序来打印一段字符串，这段程序不依赖任何链接库就可以打印出字符串内容，读者如果不懂其中的含义也不用担心，只需要了解下面介绍的链接知识就好。

```
const char*str = "hello";

void print(){
	asm("movl $13, %%edx \n\t"
		"movl str,%%ecx \n\t"
        "movl $0,%%ebx \n\t"
        "movl $4,%%eax \n\t"
        "int $0x80 \n\t"
        :
        :"r"(str):"edx", "ecx", "ebx"
			);
}
void exit(){
void exit() {
    asm("movl $42,%ebx \n\t"
        "movl $1,%eax \n\t"
        "int $0x80 \n\t");
}

void nomain() {
    print();
    exit();
}
}
```

```
gcc -c fno-builtin test.c
```

```
~/test$ nm -a test.o
0000000000000000 b .bss
0000000000000000 n .comment
0000000000000000 d .data
0000000000000000 d .data.rel.local
0000000000000000 r .eh_frame
0000000000000000 n .note.GNU-stack
0000000000000000 r .rodata
0000000000000000 t .text
0000000000000026 T _Z4exitv
0000000000000000 T _Z5printv
0000000000000039 T _Z6nomainv
0000000000000000 D str
0000000000000000 a test.cc
```

这里由于我的源文件是.cc结尾，所以是以c++方式编译的，所以符号变成了上面的形式，如果变成了test.c，符号如下：

```
~/test$ gcc -c -fno-builtin test.c -o test.o
~/test$ nm -a test.o
0000000000000000 b .bss
0000000000000000 n .comment
0000000000000000 d .data
0000000000000000 d .data.rel.local
0000000000000000 r .eh_frame
0000000000000000 n .note.GNU-stack
0000000000000000 r .rodata
0000000000000000 t .text
0000000000000026 T exit
0000000000000039 T nomain
0000000000000000 T print
0000000000000000 D str
0000000000000000 a test.c
```

```
再使用-e指定入口函数符号：

~/test$ ld -static -e nomain -o test test.o
~/test$ ./test
hello
```

如何使用自定义链接脚本实现自定义段的功能

在ld链接过程中使用-T参数可以指定链接脚本，通过ld -verbose可以查看默认的链接脚本，原文太长，这里简单截取了一部分：

```
$ ld -verbose
GNU ld (GNU Binutils for Ubuntu) 2.30
  Supported emulations:
   elf_x86_64
   elf32_x86_64
   elf_i386
   elf_iamcu
   i386linux
   elf_l1om
   elf_k1om
   i386pep
   i386pe
using internal linker script:
==================================================
/* Script for -z combreloc: combine and sort reloc sections */
/* Copyright (C) 2014-2018 Free Software Foundation, Inc.
   Copying and distribution of this script, with or without modification,
   are permitted in any medium without royalty provided the copyright
   notice and this notice are preserved.  */
OUTPUT_FORMAT("elf64-x86-64", "elf64-x86-64",
              "elf64-x86-64")
OUTPUT_ARCH(i386:x86-64)
ENTRY(_start)
SEARCH_DIR("=/usr/local/lib/x86_64-linux-gnu"); SEARCH_DIR("=/lib/x86_64-linux-gnu"); SEARCH_DIR("=/usr/lib/x86_64-linux-gnu"); SEARCH_DIR("=/usr/lib/x86_64-linux-gnu64"); SEARCH_DIR("=/usr/local/lib64"); SEARCH_DIR("=/lib64"); SEARCH_DIR("=/usr/lib64"); SEARCH_DIR("=/usr/local/lib"); SEARCH_DIR("=/lib"); SEARCH_DIR("=/usr/lib"); SEARCH_DIR("=/usr/x86_64-linux-gnu/lib64"); SEARCH_DIR("=/usr/x86_64-linux-gnu/lib");
SECTIONS
{
  /* Read-only sections, merged into text segment: */
  PROVIDE (__executable_start = SEGMENT_START("text-segment", 0x400000)); . = SEGMENT_START("text-segment", 0x400000) + SIZEOF_HEADERS;

  .init           :
  {
    KEEP (*(SORT_NONE(.init)))
  }
  .plt            : { *(.plt) *(.iplt) }
  .plt.got        : { *(.plt.got) }
  .plt.sec        : { *(.plt.sec) }
  .text           :
  {
    *(.text.unlikely .text.*_unlikely .text.unlikely.*)
    *(.text.exit .text.exit.*)
    *(.text.startup .text.startup.*)
    *(.text.hot .text.hot.*)
    *(.text .stub .text.* .gnu.linkonce.t.*)
    /* .gnu.warning sections are handled specially by elf32.em.  */
    *(.gnu.warning)
  }
  .fini           :
  {
    KEEP (*(SORT_NONE(.fini)))
  }
  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }
  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }
}
```

这里自定义一个简单的链接脚本test.lds

```
ENTRY(nomain)

SECTIONS
{
    . = 0x8048000 + SIZEOF_HEADERS;
    tinytext : { *(.text) *(.data) *(.rodata) }
    /DISCARD/ : { *(.comment) }
}
```

再使用-T指定链接脚本：

```
~/test$ ld -static -T test.lds -e nomain -o test test.o
~/test$ ./test
hello
```

```
再使用-T指定链接脚本：
~/test$ ld -static -T test.lds -e nomain -o test test.o
~/test$ ./test
hello

上面的tinytext一行是指将.text段、.data段、.rodata段的内容都合并到tinytext段中，使用readelf查看段的信息。

~/test$ readelf -S test
~/test$ There are 6 section headers, starting at offset 0x482a0:

Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .eh_frame         PROGBITS         00000000080480b0  000480b0
       0000000000000078  0000000000000000   A       0     0     8
  [ 2] tinytext          PROGBITS         0000000008048128  00048128
       0000000000000066  0000000000000000 WAX       0     0     8
  [ 3] .shstrtab         STRTAB           0000000000000000  0004826e
       000000000000002e  0000000000000000           0     0     1
  [ 4] .symtab           SYMTAB           0000000000000000  00048190
       00000000000000c0  0000000000000018           5     4     8
  [ 5] .strtab           STRTAB           0000000000000000  00048250
       000000000000001e  0000000000000000           0     0     1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), l (large)
  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)
  O (extra OS processing required) o (OS specific), p (processor specific)
```

关于静态链接库：

```
ar rcs libxxx.a xx1.o xx2.o 打包静态链接库
ar -t libc.a 查看静态链接库里都有什么目标文件
ar -x libc.a 会解压所有的目标文件到当前目录
gcc --verbose 可以查看整个编译链接步骤
```

关于objdump：

```
objdump -i 查看本机目标架构
objdump -f 显示文件头信息
objdump -d 反汇编程序
objdump -t 显示符号表入口，每个目标文件都有什么符号
objdump -r 显示文件的重定位入口，重定位表
objdump -x 显示所有可用的头信息，等于-a -f -h -r -t
objdump -H 帮助
```

关于分析ELF文件格式：

```
readelf -h 列出文件头
readelf -S 列出每个段
readelf -r 列出重定位表
readelf -d 列出动态段
```

关于查看目标文件符号信息：

```
nm -a 显示所有的符号
nm -D 显示动态符号
nm -u 仅显示没有定义的外部符号
nm -defined-only 仅显示定义的符号
```

关于符号的说明：

如果符号类型是小写的，表明符号是局部符号，大写表示符号是全局符号。

- A：该符号的值是绝对的，在以后的链接过程中，不允许进行改变。这样的符号值，常常出现在中断向量表中，例如用符号来表示各个中断向量函数在中断向量表中的位置。
- B：该符号的值出现在.bss段中，未初始化的全局和静态变量。
- C：该符号的值在COMMON段中，里面的都是弱符号。
- D：该符号位于数据段中。
- I：该符号对另一个符号的间接引用
- N：debug符号
- R：该符号位于只读数据区
- T：该符号位于代码段
- U：该符号在当前文件未定义，定义在别的文件中
- ?：该符号类型没有定义



###### 3.如何确定某个函数有被编译输出？

在linux下可以用nm指令查看

```
$ nm test.o
                U _GLOBAL_OFFSET_TABLE_
0000000000000000 T main
                U put
```

也可以用objdump指令

![image-20210626131951493](C:\Users\10594\AppData\Roaming\Typora\typora-user-images\image-20210626131951493.png)

反汇编

```
objdump -t test.o

test.o:     file format elf64-x86-64

SYMBOL TABLE:
0000000000000000 l    df *ABS*  0000000000000000 test_c.cc
0000000000000000 l    d .text  0000000000000000 .text
0000000000000000 l    d .data  0000000000000000 .data
0000000000000000 l    d .bss   0000000000000000 .bss
0000000000000000 l    d .rodata        0000000000000000 .rodata
0000000000000000 l    d .note.GNU-stack        0000000000000000 .note.GNU-stack
0000000000000000 l    d .eh_frame      0000000000000000 .eh_frame
0000000000000000 l    d .comment       0000000000000000 .comment
0000000000000000 g     F .text  0000000000000017 main
0000000000000000         *UND*  0000000000000000 _GLOBAL_OFFSET_TABLE_
0000000000000000         *UND*  0000000000000000 puts
```

还有command readlf:

```
readelf -s test.o

Symbol table '.symtab' contains 12 entries:
  Num:    Value          Size Type    Bind   Vis      Ndx Name
    0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND
    1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS test_c.cc
    2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1
    3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3
    4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4
    5: 0000000000000000     0 SECTION LOCAL  DEFAULT    5
    6: 0000000000000000     0 SECTION LOCAL  DEFAULT    7
    7: 0000000000000000     0 SECTION LOCAL  DEFAULT    8
    8: 0000000000000000     0 SECTION LOCAL  DEFAULT    6
    9: 0000000000000000    23 FUNC    GLOBAL DEFAULT    1 main
   10: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _GLOBAL_OFFSET_TABLE_
   11: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND puts
```



###### 4.动态链接库和静态链接库的区别是什么？

**Linux如何装载并运行ELF程序**

Linux内核装载ELF文件主要有两步：

1. **通过fork系统调用创建一个新的进程**

2. **通过execve系统调用执行指定的ELF文件，附带环境变量和参数**

3. 1. 检查ELF可执行文件的有效性，比如魔数（通过魔数可以确定文件格式）、Segment的数量等
   2. 寻找动态链接的段，设置动态链接器路径
   3. 根据ELF可执行文件的程序头表描述，对ELF文件进行映射，比如代码、数据、只读数据
   4. 初始化ELF进程环境
   5. 将系统调用的返回地址修改为ELF可执行文件的入口地址

**为什么要进行动态链接？**

因为静态链接有缺点：

1. 浪费内存和磁盘空间：如下图，

![image-20210626124538981](C:\Users\10594\AppData\Roaming\Typora\typora-user-images\image-20210626124538981.png)

Program1和Program2分别包含Program1.o和Program2.o两个模块，他们都需要Lib.o模块。静态链接情况下，两个目标文件都用到Lib.o这个模块，所以它们同时在链接输出的可执行文件Program1和program2中有副本，同时运行时，Lib.o在磁盘和内存中有两份副本，当系统中有大量类似Lib.o的多个程序共享目标文件时，就会浪费很大空间。

1. 静态链接对程序的更新部署和发布很不友好：假如一个模块依赖20个模块，当20个模块其中有一个模块需要更新时，需要将所有的模块都找出来重新编译出一个可执行程序才可以更新成功，每次更新任何一个模块，用户就需要重新获得一个非常大的程序，程序如果使用静态链接，那么通过网络来更新程序也会非常不便，一旦程序任何位置有一个小改动，都会导致整个程序重新下载。

![image-20210626124815609](C:\Users\10594\AppData\Roaming\Typora\typora-user-images\image-20210626124815609.png)

多个程序依赖同一个共享目标文件，这个共享目标文件在磁盘和内存中仅有一份，不会产生副本，简单来讲就是不像静态链接一样对那些组成程序的目标文件进行链接，等到程序要运行时才进行链接，把链接这个过程推迟到运行时才执行。动态链接的方式使得开发过程中各个模块更加独立，耦合度更小，便于不同的开发者和开发组织之间独立的进行开发和测试。

**如何进行动态链接**？

```c
//lib.c
#include <stdio.h>

void func(int i){
	printf("func %d\n",i);
}

//program.c
void func(int i);

int main(){
	func(1);
    return 0;
}
```

编译运行过程如下：

```
$ gcc -fPIC -shared -o lib.so lib.c
$ gcc -o test Program.c ./lib.so
./test
func 1
```

通过-fPIC和-shared可以生成一个动态链接库，再链接到可执行程序就可以正常运行。

通过readelf命令可以查看动态链接库的segment信息：

```
~/test$ readelf -l lib.so

Elf file type is DYN (Shared object file)
Entry point 0x530
There are 7 program headers, starting at offset 64

Program Headers:
 Type           Offset             VirtAddr           PhysAddr
                FileSiz            MemSiz              Flags  Align
 LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000
                0x00000000000006e4 0x00000000000006e4  R E    0x200000
 LOAD           0x0000000000000e10 0x0000000000200e10 0x0000000000200e10
                0x0000000000000218 0x0000000000000220  RW     0x200000
 DYNAMIC        0x0000000000000e20 0x0000000000200e20 0x0000000000200e20
                0x00000000000001c0 0x00000000000001c0  RW     0x8
 NOTE           0x00000000000001c8 0x00000000000001c8 0x00000000000001c8
                0x0000000000000024 0x0000000000000024  R      0x4
 GNU_EH_FRAME   0x0000000000000644 0x0000000000000644 0x0000000000000644
                0x0000000000000024 0x0000000000000024  R      0x4
 GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                0x0000000000000000 0x0000000000000000  RW     0x10
 GNU_RELRO      0x0000000000000e10 0x0000000000200e10 0x0000000000200e10
                0x00000000000001f0 0x00000000000001f0  R      0x1

Section to Segment mapping:
 Segment Sections...
  00     .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .init .plt .plt.got .text .fini .rodata .eh_frame_hdr .eh_frame
  01     .init_array .fini_array .dynamic .got .got.plt .data .bss
  02     .dynamic
  03     .note.gnu.build-id
  04     .eh_frame_hdr
  05
  06     .init_array .fini_array .dynamic .got
```

可以看见动态链接模块的装载地址从0开始，0是无效地址，它的装载地址会在程序运行时再确定，在编译时是不确定的。

改一下程序：

```
// Program.c
#include <stdio.h>
void func(int i);

int main() {
   func(1);
   sleep(-1);
   return 0;
}
```

运行读取maps信息：

```
~/test$ ./test &
[1] 126
~/test$ func 1
cat /proc/126/maps
7ff2c59f0000-7ff2c5bd7000 r-xp 00000000 00:00 516391             /lib/x86_64-linux-gnu/libc-2.27.so
7ff2c5bd7000-7ff2c5be0000 ---p 001e7000 00:00 516391             /lib/x86_64-linux-gnu/libc-2.27.so
7ff2c5be0000-7ff2c5dd7000 ---p 000001f0 00:00 516391             /lib/x86_64-linux-gnu/libc-2.27.so
7ff2c5dd7000-7ff2c5ddb000 r--p 001e7000 00:00 516391             /lib/x86_64-linux-gnu/libc-2.27.so
7ff2c5ddb000-7ff2c5ddd000 rw-p 001eb000 00:00 516391             /lib/x86_64-linux-gnu/libc-2.27.so
7ff2c5ddd000-7ff2c5de1000 rw-p 00000000 00:00 0
7ff2c5df0000-7ff2c5df1000 r-xp 00000000 00:00 189022             /mnt/d/wzq/wzq/util/test/lib.so
7ff2c5df1000-7ff2c5df2000 ---p 00001000 00:00 189022             /mnt/d/wzq/wzq/util/test/lib.so
7ff2c5df2000-7ff2c5ff0000 ---p 00000002 00:00 189022             /mnt/d/wzq/wzq/util/test/lib.so
7ff2c5ff0000-7ff2c5ff1000 r--p 00000000 00:00 189022             /mnt/d/wzq/wzq/util/test/lib.so
7ff2c5ff1000-7ff2c5ff2000 rw-p 00001000 00:00 189022             /mnt/d/wzq/wzq/util/test/lib.so
7ff2c6000000-7ff2c6026000 r-xp 00000000 00:00 516353             /lib/x86_64-linux-gnu/ld-2.27.so
7ff2c6026000-7ff2c6027000 r-xp 00026000 00:00 516353             /lib/x86_64-linux-gnu/ld-2.27.so
7ff2c6227000-7ff2c6228000 r--p 00027000 00:00 516353             /lib/x86_64-linux-gnu/ld-2.27.so
7ff2c6228000-7ff2c6229000 rw-p 00028000 00:00 516353             /lib/x86_64-linux-gnu/ld-2.27.so
7ff2c6229000-7ff2c622a000 rw-p 00000000 00:00 0
7ff2c62e0000-7ff2c62e3000 rw-p 00000000 00:00 0
7ff2c62f0000-7ff2c62f2000 rw-p 00000000 00:00 0
7ff2c6400000-7ff2c6401000 r-xp 00000000 00:00 189023             /mnt/d/wzq/wzq/util/test/test
7ff2c6600000-7ff2c6601000 r--p 00000000 00:00 189023             /mnt/d/wzq/wzq/util/test/test
7ff2c6601000-7ff2c6602000 rw-p 00001000 00:00 189023             /mnt/d/wzq/wzq/util/test/test
7fffee96f000-7fffee990000 rw-p 00000000 00:00 0                 [heap]
7ffff6417000-7ffff6c17000 rw-p 00000000 00:00 0                 [stack]
7ffff729d000-7ffff729e000 r-xp 00000000 00:00 0                 [vdso]
```

可以看到，整个进程虚拟地址空间中，多出了几个文件的映射，lib.so和test一样，它们都是被操作系统用同样的方法映射到进程的虚拟地址空间，只是它们占据的虚拟地址和长度不同，从maps里可以看见里面还有libc-2.27.so，这是C语言运行库，还有一个ld-2.27.so，这是Linux下的动态链接器，动态链接器和普通共享对象一样被映射到进程的地址空间，在系统开始运行test前，会先把控制权交给动态链接器，动态链接器完成所有的动态链接工作后会把控制权交给test，然后执行test程序。

当链接器将Program.o链接成可执行文件时，这时候链接器必须确定目标文件中所引用的func函数的性质，如果是一个定义于其它静态目标文件中的函数，那么链接器将会按照静态链接的规则，将Program.o的func函数地址进行重定位，如果func是一个定义在某个动态链接共享对象中的函数，那么链接器将会将这个符号的引用标记为一个动态链接的符号，不对它进行地址重定位，将这个过程留在装载时再进行。

###### 动态链接的方式

动态链接有两种方式：装载时重定位和地址无关代码技术。

装载时重定位：在链接时对所有绝对地址的引用不作重定位，而把这一步推迟到装载时完成，也叫基址重置，每个指令和数据相当于模块装载地址是固定的，系统会分配足够大的空间给装载模块，当装载地址确定后，那指令和数据地址自然也就确定了。然而动态链接模块被装载映射到虚拟空间，指令被重定位后对于每个进程来讲是不同的，没有办法做到同一份指令被多个进程共享，所以指令对不同的进程来说有不同的副本，还是空间浪费，怎么解决这个问题？**使用fPIC方法。**

地址无关代码：指令部分无法在多个进程之间共享，不能节省内存，所以引入了地址无关代码的技术。我们平时编程过程中可能都见过-fPIC的编译选项，这个就代表使用了地址无关代码技术来实现真正的动态链接。基本思想就是使用GOT（全局偏移表），这是一个指向变量或函数地址的指针数组，当指令要访问变量或者调用函数时，会去GOT中找到相应的地址进行间接跳转访问，每个变量或函数都对应一个地址，链接器在装载模块的时候会查找每个变量和函数的地址，然后填充GOT中的各个项，确保每个指针指向的地址正确。GOT放在数据段，所以它可以在模块装载时被修改，并且每个进程都可以有独立的副本，相互不受影响。

-fpic和-fPIC的区别：它们都是地址无关代码技术，-fpic产生的代码相对较小较快，但是在某些平台会有些限制，所以大多数情况下都是用-fPIC来产生地址无关代码。

-fPIC和-fPIE的区别：一个作用于共享对象，一个作用于可执行文件，一个以地址无关方式编译的可执行文件被称作地址无关可执行文件。

-fpie和-fPIE的区别：类似于-fpic和-fPIC的区别

**延迟绑定技术**

在程序刚启动时动态链接器会寻找并装载所需要的共享对象，然后进行符号地址寻址重定位等工作，这些工作会减慢程序的启动速度，如果解决？

使用PLT延迟绑定技术，这里会单独有一个叫.PLT的段，ELF将 GOT拆分成两个表.GOT和.GOT.PLT，其中.GOT用来保存全局变量的引用地址，.GOT.PLT用来保存外部函数的地址，每个外部函数在PLT中都有一个对应项，在初始化时不会绑定，而是在函数第一次被用到时才进行绑定，将函数真实地址与对应表项进行绑定，之后就可以进行间接跳转。

###### 显式运行时链接

支持动态链接的系统往往都支持显式运行时链接，也叫运行时加载，让程序自己在运行时控制加载的模块，在需要时加载需要的模块，在不需要时将其卸载。这种运行时加载方式使得程序的模块组织变得很灵活，可以用来实现一些诸如插件、驱动等功能。

通过这四个API可以进行显式运行时链接：

```
dlopen():打开动态链接库
dlsym():查找符号
dlerror():错误处理
dlclose():关闭动态链接库
```

```c++
#include <stdio.h>
#include <dlfcn.h>

int main() {
   
   void *handle;
   void (*f)(int);
   char *error;

   handle = dlopen("./lib.so", RTLD_NOW);
   if (handle == NULL) {
       printf("handle null \n");
       return -1;
  }
   f = dlsym(handle, "func");
   do {
       if ((error = dlerror()) != NULL) {
           printf("error\n");
           break;
      }
       f(100);
  } while (0);
   dlclose(handle);

   return 0;
}
```

```
$ gcc -o test program.c -ldl
$ ./test
func 100
```

**为什么要进行动态链接？****为了解决静态链接浪费空间和更新困难的缺点。**

**动态链接的方式？****装载时重定位和地址无关代码技术。**

**地址无关代码技术原理？****通过GOT段实现间接跳转。**

**延迟加载技术原理？****对外部函数符号通过PLT段实现延迟绑定及间接跳转。**

**如果进行显式运行时链接？****通过<dlfcn.h>头文件中的四个函数，代码如上。**